#!/usr/bin/env python3
from argparse import ArgumentParser
from pathlib import Path
import shutil
import os
import json
import subprocess
import time
import shlex
import re

parser = ArgumentParser(description="Generates a new compile_commands.json for Embedded Swift + pico-sdk")
parser.add_argument("-b", "--build", help="Build directory", default=os.getcwd())
parser.add_argument("-i", "--input", help="Input file", default="./compile_commands.json")
parser.add_argument("-o", "--output", help="Output file", default="./compile_commands.json")
parser.add_argument("--cc", help="C compiler path for c_cpp_properties.json", default=shutil.which("arm-none-eabi-gcc"))
parser.add_argument("--c_cpp_properties", help="Output file for c_cpp_properties.json", default=None)
parser.add_argument("--ninja", help="ninja tool path", default=shutil.which("ninja"))
parser.add_argument("--wait_cmake", help="Wait cmake generating process", action="store_true")
parser.add_argument("--input_file_timestamp", help="input file timestamp for wait_cmake", default=None)
args = parser.parse_args()

def input_file_timestamp() -> str:
    return str(os.stat(args.input).st_mtime_ns if os.path.exists(args.input) else 0)

if args.wait_cmake:
    subprocess.Popen(
        [
            "python3", __file__,
            "--build", args.build,
            "--input", args.input,
            "--output", args.output,
            "--cc", args.cc,
            "--c_cpp_properties", args.c_cpp_properties,
            "--ninja", args.ninja,
            "--input_file_timestamp", input_file_timestamp(),
        ],
        cwd=os.getcwd(),
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
        preexec_fn=os.setpgrp
    )
    exit(0)

if args.input_file_timestamp is not None:
    wait_start = time.time()
    while wait_start < time.time() + 60: # timeout 60s
        if input_file_timestamp() != args.input_file_timestamp:
            time.sleep(0.1)
            break
        time.sleep(0.1)

swift_compilation_commands: list[str] = []
try:
    ninja_invocation = subprocess.run([args.ninja, "-t", "compdb"], cwd=args.build, capture_output=True)
    ninja_compdb = json.loads(ninja_invocation.stdout.decode("utf-8", errors="ignore"))
    for file_cmd in ninja_compdb:
        file = file_cmd.get("file")
        if file is None or not file.endswith('.swift'):
            continue
        cmd = file_cmd.get('command')
        # Skip invocations that are used to emit the header file for C++.
        if cmd.find('-emit-clang-header') != -1:
            continue

        # Cleanup '&&' and ':' tokens from command generated by Ninja.
        cmd = shlex.join((x for x in shlex.split(cmd) if x != '&&' and x != ':'))
        swift_compilation_commands.append(cmd)
except:
    print("error: failed to aquire Swift compilation commands")

compile_commands = json.loads(Path(args.input).read_text(encoding="utf-8", errors="ignore"))
for cmd in compile_commands:
    file = cmd.get("file")
    if file is None or not file.endswith(".swift") or cmd.get("command") != ":":
        continue
    for swift_cmd in swift_compilation_commands:
        if swift_cmd.find(file) != -1:
            cmd["command"] = swift_cmd
            break

os.makedirs(os.path.dirname(os.path.abspath(args.output)), exist_ok=True)
with open(args.output, "w") as f:
    json.dump(compile_commands, f, indent=2)

# generate c_cpp_properties.json for c headers
if args.c_cpp_properties is not None and len(compile_commands) > 0:
    include_path: list[str] = []
    for match in re.finditer(r"-Xcc -I\s*([^\s]+)", compile_commands[0]["command"]):
        include_path.append(match.group(1))
    defines: list[str] = []
    for match in re.finditer(r"-Xcc -D\s*([^\s]+)", compile_commands[0]["command"]):
        if match.group(1).find("=") == -1:
            defines.append(match.group(1) + "=1")
        else:
            defines.append(match.group(1))
    c_cpp_properties = {
        "configurations": [
            {
                "name": "pico-sdk",
                "includePath": include_path,
                "defines": defines,
                "compileCommands": os.path.abspath(args.output),
                "compilerPath": args.cc,
            }
        ],
        "version": 4
    }
    os.makedirs(os.path.dirname(os.path.abspath(args.c_cpp_properties)), exist_ok=True)
    with open(args.c_cpp_properties, "w") as f:
        json.dump(c_cpp_properties, f, indent=2)
